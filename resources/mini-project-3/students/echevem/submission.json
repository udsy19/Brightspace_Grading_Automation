{
  "student_name": "None None",
  "org_defined_id": "036820322",
  "username": "echevem",
  "video_url": "",
  "transcript": "Hey everyone, My name is Mauricio. Today I'm breaking down how I built FinMind AI, a personalized financial planning app that blends deterministic math with AI-powered reasoning. I'm going to walk you through the architecture, how each part of the system works, and how the whole thing aligns with the DRIVER method for structured decision-making. This will give you an inside look at how modern AI apps are actually built, and how we use context, guardrails, and reasoning to create something that feels smart and reliable.\n\nLet's start with the Profile and Goals pages, which act as the memory of the entire application. These pages store everything that defines the user's financial reality: income, expenses, debt, savings, goals, and risk tolerance. Instead of letting the AI guess who the user is, we store all of this as structured data inside the database. This way, every single AI prompt begins with perfect context, and the system never hallucinates or invents details. It always knows exactly who it's advising, because the app explicitly injects this profile data into each request.\nNext, the Dashboard—or the Home page—acts as the truth layer of the app. This page doesn't use AI at all. Instead, it fetches the raw financial information from the Profile and Goals and performs simple, deterministic math. Net worth is calculated as savings minus debt. Cashflow is income minus expenses. These numbers are exact, predictable, and objective. The whole point of the Dashboard is to provide a factual snapshot of the user's financial health, which becomes the baseline against which all AI-generated recommendations and scenarios are evaluated. Before the AI can think, it needs truth, and this page provides it.\nNow let's move into the AI Advisor, which introduces intelligence into the system. Whenever a user asks a financial question, the first thing the app does is fetch the latest UserProfile and Goals from the database. This step, called context injection, ensures the AI understands the user's financial situation before generating a response. Then the app constructs a system prompt behind the scenes. It might say something like: \"You are a financial advisor. The user makes X, has Y debt, and is saving for Z. Answer based on this.\" This keeps the AI grounded, consistent, and professional. We also enabled retrieval-augmented generation, so the AI can fetch real-time financial information from the internet—things like current interest rates, market conditions, and economic news. This is incredibly useful when answering questions such as \"Is it a good time to buy bonds right now?\" because the AI can incorporate real-world data into the reasoning process.\nFor the most advanced part of the system, we have the Scenario Simulator. Instead of asking the AI for paragraphs of text, the app forces it to return a very strict JSON structure. The output must include a feasibility score, a verdict, and lists of pros and cons. This design turns the AI into a predictable engine that can be parsed like an API, rather than a creative writer. When a user enters a scenario—for example, \"Can I afford a $50,000 Tesla?\"—the AI compares that scenario against their actual financial profile. Instead of saying something vague like \"This looks expensive,\" it reasons: \"You save four thousand dollars a month, so this purchase is technically possible, but it may delay your house down-payment goal.\" After the AI responds with the structured JSON, the app renders everything visually with color-coded scores, verdict labels like \"Excellent\" or \"High Risk,\" and well-organized pro-and-con lists. It transforms financial reasoning into something clear, visual, and actionable.\n\nAll of this ties into the DRIVER method, which shaped the entire architecture. The Discover phase happens in the Profile and Goals pages, where the app gathers the user's financial details explicitly instead of assuming anything. Reason happens inside the Advisor and Simulator, where the AI uses the structured context to make personalized judgments based on the user's actual situation. Implement refers to the technical integration—things like connecting to external data sources, injecting system prompts, and enforcing JSON schemas. Verify is handled by the Scenario Simulator through its feasibility score, which acts like a financial safety check before the user makes a big decision. Evolve happens automatically as the user updates their profile; the AI's advice adapts instantly as their financial life changes. Finally, Reflect is about the development process itself. Building FinMind required shifting from deterministic programming, where everything has a fixed answer, to probabilistic design, where the AI's output depends on context and reasoning. Instead of writing long if-else chains for financial logic, the goal became designing prompts, guardrails, and structures that guide the AI toward professional, consistent conclusions. The code becomes a container for intelligence, not the intelligence itself.\nAnd that's how FinMind AI works behind the scenes. If you enjoyed this breakdown and want to see deeper dives into the architecture, the prompt engineering, or the Scenario Simulator, hit like, subscribe, and let me know what you'd like me to explore next. Thanks for watching, and I'll see you in the next one."
}